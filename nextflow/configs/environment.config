/*
 * Environment Management Configuration
 * 
 * This configuration provides flexible environment management for the MetaNextViro pipeline
 * supporting both unified and per-process conda environments
 */

// Environment management parameters
params {
    // Environment mode: 'unified' or 'per_process'
    env_mode = params.env_mode ?: 'unified'
    
    // Environment validation settings
    validate_environments = params.validate_environments ?: true
    auto_resolve_conflicts = params.auto_resolve_conflicts ?: true
    strict_env_validation = params.strict_env_validation ?: false
    
    // Environment file paths (can be overridden)
    unified_env = "${projectDir}/environments/unified.yml"
    process_envs_dir = "${projectDir}/environments"
    
    // Environment setup options
    create_missing_envs = params.create_missing_envs ?: false
    backup_env_files = params.backup_env_files ?: true
    
    // Conda-specific settings
    conda_cache_dir = params.conda_cache_dir ?: null
    conda_create_timeout = params.conda_create_timeout ?: '30m'
    conda_create_options = params.conda_create_options ?: ''
}

// Configure process environments based on mode
if (params.env_mode == 'unified') {
    // Unified environment configuration
    process {
        conda = "${projectDir}/environments/unified.yml"
        
        // Conda-specific settings can be added here if needed
    }
    
    // Using unified conda environment
    
} else if (params.env_mode == 'per_process') {
    // Per-process environment configuration
    process {
        // Quality control processes
        withName: 'FASTQC' {
            conda = "${projectDir}/environments/qc.yml"
        }
        withName: 'MULTIQC' {
            conda = "${projectDir}/environments/qc.yml"
        }
        
        // Trimming processes
        withName: 'FASTP' {
            conda = "${projectDir}/environments/trimming.yml"
        }
        withName: 'FLEXBAR' {
            conda = "${projectDir}/environments/trimming.yml"
        }
        withName: 'TRIM_GALORE' {
            conda = "${projectDir}/environments/trimming.yml"
        }
        
        // Assembly processes
        withName: 'MEGAHIT' {
            conda = "${projectDir}/environments/assembly.yml"
        }
        withName: 'METASPADES' {
            conda = "${projectDir}/environments/assembly.yml"
        }
        withName: 'HYBRID_ASSEMBLY' {
            conda = "${projectDir}/environments/assembly.yml"
        }
        withName: 'QUAST' {
            conda = "${projectDir}/environments/assembly.yml"
        }
        
        // Annotation processes
        withName: 'BLASTN' {
            conda = "${projectDir}/environments/annotation.yml"
        }
        withName: 'BLASTN_VIRUSES' {
            conda = "${projectDir}/environments/annotation.yml"
        }
        withName: 'BLASTX' {
            conda = "${projectDir}/environments/annotation.yml"
        }
        withName: 'DIAMOND_BLASTX' {
            conda = "${projectDir}/environments/annotation.yml"
        }
        withName: 'CD_HIT' {
            conda = "${projectDir}/environments/annotation.yml"
        }
        
        // Taxonomic classification processes
        withName: 'KRAKEN2' {
            conda = "${projectDir}/environments/taxonomy.yml"
        }
        withName: 'KRONA' {
            conda = "${projectDir}/environments/taxonomy.yml"
        }
        
        // Viral analysis processes
        withName: 'CHECKV' {
            conda = "${projectDir}/environments/viral.yml"
        }
        withName: 'VIRFINDER' {
            conda = "${projectDir}/environments/viral.yml"
        }
        
        // Alignment processes
        withName: 'BOWTIE2' {
            conda = "${projectDir}/environments/alignment.yml"
        }
        withName: 'SAMTOOLS' {
            conda = "${projectDir}/environments/alignment.yml"
        }
        withName: 'BEDTOOLS' {
            conda = "${projectDir}/environments/alignment.yml"
        }
        withName: 'COVERAGE' {
            conda = "${projectDir}/environments/alignment.yml"
        }
        
        // Global conda settings for all processes can be added here if needed
    }
    
    // Using per-process conda environments
    
} else {
    error "Invalid environment mode: ${params.env_mode}. Must be 'unified' or 'per_process'"
}

// Environment validation helper functions
def getEnvironmentMode() {
    return params.env_mode
}

def isUnifiedMode() {
    return params.env_mode == 'unified'
}

def isPerProcessMode() {
    return params.env_mode == 'per_process'
}

def getUnifiedEnvironmentPath() {
    return "${projectDir}/environments/unified.yml"
}

def getPerProcessEnvironmentPath(String processName) {
    // Process to environment mapping
    def processMapping = [
        'FASTQC': 'qc',
        'MULTIQC': 'qc',
        'FASTP': 'trimming',
        'FLEXBAR': 'trimming',
        'TRIM_GALORE': 'trimming',
        'MEGAHIT': 'assembly',
        'METASPADES': 'assembly',
        'HYBRID_ASSEMBLY': 'assembly',
        'QUAST': 'assembly',
        'BLASTN': 'annotation',
        'BLASTN_VIRUSES': 'annotation',
        'BLASTX': 'annotation',
        'DIAMOND_BLASTX': 'annotation',
        'CD_HIT': 'annotation',
        'KRAKEN2': 'taxonomy',
        'KRONA': 'taxonomy',
        'CHECKV': 'viral',
        'VIRFINDER': 'viral',
        'BOWTIE2': 'alignment',
        'SAMTOOLS': 'alignment',
        'BEDTOOLS': 'alignment',
        'COVERAGE': 'alignment'
    ]
    
    def envCategory = processMapping[processName]
    if (envCategory) {
        return "${projectDir}/environments/${envCategory}.yml"
    } else {
        // Fallback to unified environment
        return getUnifiedEnvironmentPath()
    }
}

def validateEnvironmentSetup() {
    def errors = []
    def warnings = []
    
    if (params.env_mode == 'unified') {
        def envFile = new File(getUnifiedEnvironmentPath())
        if (!envFile.exists()) {
            errors << "Unified environment file not found: ${getUnifiedEnvironmentPath()}"
        }
    } else if (params.env_mode == 'per_process') {
        def envFiles = ['qc.yml', 'trimming.yml', 'assembly.yml', 'annotation.yml', 'taxonomy.yml', 'viral.yml', 'alignment.yml']
        envFiles.each { envFile ->
            def fullPath = "${projectDir}/environments/${envFile}"
            def file = new File(fullPath)
            if (!file.exists()) {
                errors << "Per-process environment file not found: ${fullPath}"
            }
        }
    }
    
    return [
        valid: errors.isEmpty(),
        errors: errors,
        warnings: warnings
    ]
}