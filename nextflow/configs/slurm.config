/*
 * SLURM cluster configuration
 * Optimized for HPC environments with intelligent partition selection
 */

// Include base configuration
includeConfig 'base.config'

// SLURM executor settings
process.executor = "slurm"

// SLURM-specific resource limits and settings
params {
    max_cpus = 128
    max_memory = '1000.GB'
    max_time = '72.h'
    
    // SLURM-specific settings
    resource_profile = 'slurm'
    enable_retry_scaling = true
    max_retry_scaling = 3
    
    // Enhanced partition mapping configuration (can be overridden by user)
    partitions = [
        compute: 'compute',
        bigmem: 'bigmem', 
        gpu: 'gpu',
        quick: 'quickq'
    ]
    
    // Partition selection thresholds and rules
    partition_thresholds = [
        bigmem_memory_gb: 128,      // Memory threshold for bigmem partition
        quick_time_hours: 1,        // Time threshold for quick partition
        quick_memory_gb: 16,        // Memory threshold for quick partition
        gpu_labels: ['process_gpu'] // Labels that require GPU partition
    ]
    
    // Partition availability and fallback configuration
    partition_fallbacks = [
        bigmem: ['compute'],        // If bigmem unavailable, try compute
        gpu: ['compute'],           // If gpu unavailable, try compute
        quick: ['compute'],         // If quick unavailable, try compute
        compute: []                 // No fallback for compute (it's the default)
    ]
    
    // Default partition and behavior
    default_partition = 'compute'
    enable_partition_validation = true
    partition_selection_strategy = 'intelligent' // Options: 'intelligent', 'static', 'user_defined'
}

// SLURM executor configuration
executor {
    name = 'slurm'
    queueSize = 100
    submitRateLimit = '10 sec'
}

// Enhanced process configuration with intelligent partition selection
process {
    queue = { selectOptimalPartition(task.label, task.memory, task.time, task.cpus) }
    
    withLabel: 'process_low' {
        cpus = { check_max(4 * task.attempt, 8) }
        memory = { check_max(8.GB * task.attempt, '32.GB') }
        time = { check_max(2.h * task.attempt, '8.h') }
        clusterOptions = { 
            def partition = selectOptimalPartition('process_low', task.memory, task.time, task.cpus)
            return generateClusterOptions('process_low', partition, task.memory, task.cpus)
        }
    }
    
    withLabel: 'process_medium' {
        cpus = { check_max(8 * task.attempt, 16) }
        memory = { check_max(16.GB * task.attempt, '64.GB') }
        time = { check_max(4.h * task.attempt, '12.h') }
        clusterOptions = { 
            def partition = selectOptimalPartition('process_medium', task.memory, task.time, task.cpus)
            return generateClusterOptions('process_medium', partition, task.memory, task.cpus)
        }
    }
    
    withLabel: 'process_high' {
        cpus = { check_max(16 * task.attempt, 32) }
        memory = { check_max(32.GB * task.attempt, '128.GB') }
        time = { check_max(8.h * task.attempt, '24.h') }
        clusterOptions = { 
            def partition = selectOptimalPartition('process_high', task.memory, task.time, task.cpus)
            return generateClusterOptions('process_high', partition, task.memory, task.cpus)
        }
    }
    
    withLabel: 'process_memory_intensive' {
        cpus = { check_max(8 * task.attempt, 16) }
        memory = { check_max(64.GB * task.attempt, '512.GB') }
        time = { check_max(12.h * task.attempt, '48.h') }
        clusterOptions = { 
            def partition = selectOptimalPartition('process_memory_intensive', task.memory, task.time, task.cpus)
            return generateClusterOptions('process_memory_intensive', partition, task.memory, task.cpus)
        }
    }
    
    withLabel: 'process_gpu' {
        cpus = { check_max(8 * task.attempt, 16) }
        memory = { check_max(32.GB * task.attempt, '128.GB') }
        time = { check_max(8.h * task.attempt, '24.h') }
        accelerator = 1
        clusterOptions = { 
            def partition = selectOptimalPartition('process_gpu', task.memory, task.time, task.cpus)
            return generateClusterOptions('process_gpu', partition, task.memory, task.cpus)
        }
    }
    
    withLabel: 'process_quick' {
        cpus = { check_max(2 * task.attempt, 4) }
        memory = { check_max(4.GB * task.attempt, '16.GB') }
        time = { check_max(30.m * task.attempt, '2.h') }
        clusterOptions = { 
            def partition = selectOptimalPartition('process_quick', task.memory, task.time, task.cpus)
            return generateClusterOptions('process_quick', partition, task.memory, task.cpus)
        }
    }
}

// Enhanced partition selection function with intelligent logic and fallbacks
def selectPartition(label, memory, time) {
    def memoryGB = memory ? (memory instanceof String ? memory.toMemory().toGiga() : memory.toGiga()) : 0
    def timeHours = time ? (time instanceof String ? time.toDuration().toHours() : time.toHours()) : 0
    
    // Get thresholds from configuration
    def bigmemThreshold = params.partition_thresholds?.bigmem_memory_gb ?: 128
    def quickTimeThreshold = params.partition_thresholds?.quick_time_hours ?: 1
    def quickMemoryThreshold = params.partition_thresholds?.quick_memory_gb ?: 16
    def gpuLabels = params.partition_thresholds?.gpu_labels ?: ['process_gpu']
    
    def selectedPartition = null
    
    // Strategy-based partition selection
    switch (params.partition_selection_strategy ?: 'intelligent') {
        case 'intelligent':
            selectedPartition = selectPartitionIntelligent(label, memoryGB, timeHours, 
                                                         bigmemThreshold, quickTimeThreshold, 
                                                         quickMemoryThreshold, gpuLabels)
            break
        case 'static':
            selectedPartition = params.partitions?.compute ?: params.default_partition
            break
        case 'user_defined':
            selectedPartition = selectPartitionUserDefined(label)
            break
        default:
            selectedPartition = selectPartitionIntelligent(label, memoryGB, timeHours, 
                                                         bigmemThreshold, quickTimeThreshold, 
                                                         quickMemoryThreshold, gpuLabels)
    }
    
    // Apply fallback logic if partition is not available
    def finalPartition = applyPartitionFallback(selectedPartition)
    
    // Log partition selection for debugging
    if (params.enable_partition_validation) {
        log.debug "Partition selection for ${label}: ${selectedPartition} -> ${finalPartition} " +
                  "(Memory: ${memoryGB}GB, Time: ${timeHours}h)"
    }
    
    return finalPartition
}

// Intelligent partition selection based on resource requirements
def selectPartitionIntelligent(label, memoryGB, timeHours, bigmemThreshold, 
                              quickTimeThreshold, quickMemoryThreshold, gpuLabels) {
    
    // Priority 1: GPU processes (highest priority)
    if (gpuLabels.any { label?.contains(it.replace('process_', '')) } || label?.contains('gpu')) {
        return params.partitions?.gpu ?: params.default_partition
    }
    
    // Priority 2: Memory-intensive processes
    if (label?.contains('memory_intensive') || memoryGB > bigmemThreshold) {
        return params.partitions?.bigmem ?: params.default_partition
    }
    
    // Priority 3: Quick processes (short time and low memory)
    if (label?.contains('quick') || 
        (timeHours > 0 && timeHours <= quickTimeThreshold && memoryGB <= quickMemoryThreshold)) {
        return params.partitions?.quick ?: params.default_partition
    }
    
    // Priority 4: High-performance processes that don't fit other categories
    if (label?.contains('high') && memoryGB <= bigmemThreshold) {
        return params.partitions?.compute ?: params.default_partition
    }
    
    // Default: Standard compute partition
    return params.partitions?.compute ?: params.default_partition
}

// User-defined partition selection based on custom mapping
def selectPartitionUserDefined(label) {
    // Check if user has defined custom partition mapping for this label
    def customMapping = params.custom_partition_mapping ?: [:]
    
    if (customMapping.containsKey(label)) {
        return customMapping[label]
    }
    
    // Fallback to default partition if no custom mapping found
    return params.partitions?.compute ?: params.default_partition
}

// Apply fallback logic when selected partition is not available
def applyPartitionFallback(selectedPartition) {
    // If partition validation is disabled, return selected partition as-is
    if (!params.enable_partition_validation) {
        return selectedPartition
    }
    
    // Check if the selected partition is available (this would require SLURM integration)
    // For now, we'll assume all configured partitions are available
    // In a real implementation, this could check `sinfo` output
    
    def availablePartitions = getAvailablePartitions()
    
    if (availablePartitions.contains(selectedPartition)) {
        return selectedPartition
    }
    
    // Apply fallback logic
    def fallbacks = params.partition_fallbacks ?: [:]
    def partitionFallbacks = fallbacks[selectedPartition] ?: []
    
    for (fallback in partitionFallbacks) {
        if (availablePartitions.contains(fallback)) {
            log.warn "Partition '${selectedPartition}' not available, using fallback: '${fallback}'"
            return fallback
        }
    }
    
    // Final fallback to default partition
    log.warn "No suitable partition found, using default: '${params.default_partition}'"
    return params.default_partition
}

// Simplified partition selection function for configuration use
def selectOptimalPartition(processLabel, memory, time, cpus = null) {
    def memoryGB = memory ? (memory instanceof String ? memory.toMemory().toGiga() : memory.toGiga()) : 0
    def timeHours = time ? (time instanceof String ? time.toDuration().toHours() : time.toHours()) : 0
    
    // Get thresholds from configuration
    def bigmemThreshold = params.partition_thresholds?.bigmem_memory_gb ?: 128
    def quickTimeThreshold = params.partition_thresholds?.quick_time_hours ?: 1
    def quickMemoryThreshold = params.partition_thresholds?.quick_memory_gb ?: 16
    def gpuLabels = params.partition_thresholds?.gpu_labels ?: ['process_gpu']
    
    def selectedPartition = null
    
    // Strategy-based partition selection
    switch (params.partition_selection_strategy ?: 'intelligent') {
        case 'intelligent':
            selectedPartition = selectPartitionIntelligent(processLabel, memoryGB, timeHours, 
                                                         bigmemThreshold, quickTimeThreshold, 
                                                         quickMemoryThreshold, gpuLabels)
            break
        case 'static':
            selectedPartition = params.partitions?.compute ?: params.default_partition
            break
        case 'user_defined':
            def customMapping = params.custom_partition_mapping ?: [:]
            selectedPartition = customMapping[processLabel] ?: params.partitions?.compute ?: params.default_partition
            break
        default:
            selectedPartition = selectPartitionIntelligent(processLabel, memoryGB, timeHours, 
                                                         bigmemThreshold, quickTimeThreshold, 
                                                         quickMemoryThreshold, gpuLabels)
    }
    
    // Apply fallback logic if partition is not available
    def finalPartition = applyPartitionFallback(selectedPartition)
    
    // Log partition selection for debugging
    if (params.enable_partition_validation) {
        log.debug "Partition selection for ${processLabel}: ${selectedPartition} -> ${finalPartition} " +
                  "(Memory: ${memoryGB}GB, Time: ${timeHours}h)"
    }
    
    return finalPartition
}

// Simplified cluster options generation
def generateClusterOptions(processLabel, partition, memory, cpus) {
    def options = []
    
    // Basic resource specifications
    if (memory) {
        def memoryMB = memory instanceof String ? memory.toMemory().toMega() : memory.toMega()
        options << "--mem=${memoryMB}M"
    }
    
    if (cpus) {
        options << "--ntasks=1"
        options << "--cpus-per-task=${cpus}"
    }
    
    // Partition-specific options
    options.addAll(getPartitionOptions(partition, processLabel, memory, cpus))
    
    // Label-specific options
    options.addAll(getLabelOptions(processLabel))
    
    // Custom options
    if (params.custom_cluster_options) {
        options.addAll(params.custom_cluster_options)
    }
    
    return options.join(' ')
}

// Get list of available partitions (placeholder for SLURM integration)
def getAvailablePartitions() {
    // In a real implementation, this could execute: sinfo -h -o "%P" | tr -d '*'
    // For now, return all configured partitions as available
    def configuredPartitions = params.partitions?.values() ?: []
    configuredPartitions << params.default_partition
    return configuredPartitions.unique()
}

// Enhanced cluster options generation with partition-specific optimizations
def getClusterOptions(label, memory, cpus) {
    def options = []
    
    // Add memory specification
    if (memory) {
        def memoryMB = memory instanceof String ? memory.toMemory().toMega() : memory.toMega()
        options << "--mem=${memoryMB}M"
    }
    
    // Add CPU specification
    if (cpus) {
        options << "--ntasks=1 --cpus-per-task=${cpus}"
    }
    
    // Get the selected partition for this process
    def selectedPartition = selectPartition(label, memory, null)
    
    // Add partition-specific optimizations
    options.addAll(getPartitionSpecificOptions(label, selectedPartition, memory, cpus))
    
    // Add label-specific options
    options.addAll(getLabelSpecificOptions(label))
    
    // Add user-defined cluster options if specified
    if (params.custom_cluster_options) {
        options.addAll(params.custom_cluster_options)
    }
    
    return options.join(' ')
}

// Get partition-specific SLURM options
def getPartitionSpecificOptions(label, partition, memory, cpus) {
    def options = []
    
    switch (partition) {
        case params.partitions?.bigmem:
            options << '--constraint=bigmem'
            // Optimize for memory-intensive workloads
            if (memory && memory.toGiga() > 256) {
                options << '--exclusive'  // Request exclusive node access for very large memory jobs
            }
            break
            
        case params.partitions?.gpu:
            options << '--gres=gpu:1'
            options << '--constraint=gpu'
            // Add GPU-specific optimizations
            if (params.gpu_type) {
                options << "--gres=gpu:${params.gpu_type}:1"
            }
            break
            
        case params.partitions?.quick:
            options << '--qos=quick'
            // Optimize for quick turnaround
            options << '--nice=100'  // Lower priority for quick jobs
            break
            
        case params.partitions?.compute:
            // Standard compute optimizations
            if (cpus && cpus >= 16) {
                options << '--constraint=compute'
            }
            break
    }
    
    return options
}

// Get label-specific SLURM options
def getLabelSpecificOptions(label) {
    def options = []
    
    switch (label) {
        case 'process_memory_intensive':
            options << '--mem-per-cpu=8G'  // Ensure adequate memory per CPU
            break
            
        case 'process_gpu':
            options << '--gres=gpu:1'
            if (params.gpu_memory_required) {
                options << "--constraint=gpu_mem_${params.gpu_memory_required}"
            }
            break
            
        case 'process_quick':
            options << '--nice=100'
            options << '--no-requeue'  // Don't requeue quick jobs
            break
            
        case 'process_high':
            // High-performance computing optimizations
            options << '--exclusive'
            break
            
        case 'process_low':
            // Allow sharing for low-resource jobs
            options << '--share'
            break
    }
    
    return options
}

// Validate partition availability (can be extended to check actual SLURM state)
def validatePartitionAvailability(partition) {
    if (!params.enable_partition_validation) {
        return true
    }
    
    // Basic validation - check if partition is in configured list
    def configuredPartitions = params.partitions?.values() ?: []
    configuredPartitions << params.default_partition
    
    if (!configuredPartitions.contains(partition)) {
        log.warn "Partition '${partition}' is not in the configured partition list"
        return false
    }
    
    // Extended validation could include:
    // - Checking SLURM partition state with `sinfo`
    // - Verifying partition accessibility
    // - Checking resource availability
    
    return true
}