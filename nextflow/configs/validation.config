/**
 * Validation Configuration for MetaNextViro Pipeline
 * 
 * This configuration file defines validation rules, error messages,
 * and validation behavior for the pipeline
 */

params {
    // Validation behavior settings
    validation {
        // Enable/disable different validation types
        enable_input_validation = true
        enable_database_validation = true
        enable_file_accessibility_checks = true
        enable_format_validation = true
        
        // Validation strictness
        strict_mode = false  // If true, warnings become errors
        fail_on_missing_optional = false  // If true, missing optional files cause failure
        
        // File format validation
        supported_formats = ['csv', 'tsv', 'xls', 'xlsx']
        preferred_format = 'csv'
        
        // Samplesheet validation
        required_columns = ['sample', 'fastq_1', 'fastq_2']
        optional_columns = ['single_end', 'strandedness']
        
        // File validation settings
        check_file_extensions = true
        allowed_fastq_extensions = ['.fastq', '.fq', '.fastq.gz', '.fq.gz']
        min_file_size_bytes = 1000  // Minimum file size to consider valid
        
        // Database validation settings
        required_databases = [
            'kraken2_db': [
                'description': 'Kraken2 taxonomic classification database',
                'type': 'directory',
                'required_files': ['hash.k2d', 'opts.k2d', 'taxo.k2d'],
                'download_url': 'https://benlangmead.github.io/aws-indexes/k2'
            ],
            'checkv_db': [
                'description': 'CheckV viral genome quality assessment database',
                'type': 'directory',
                'required_files': ['genome_db', 'hmm_db'],
                'download_url': 'https://portal.nersc.gov/CheckV/'
            ]
        ]
        
        optional_databases = [
            'blastdb_viruses': [
                'description': 'NCBI BLAST viral sequences database',
                'type': 'blast_db',
                'extensions': ['.nal', '.nhr', '.nin', '.nsq'],
                'condition': { params.blast_options?.contains('viruses') || params.blast_options?.contains('all') }
            ],
            'blastdb_nt': [
                'description': 'NCBI BLAST nucleotide database',
                'type': 'blast_db', 
                'extensions': ['.nal', '.nhr', '.nin', '.nsq'],
                'condition': { params.blast_options?.contains('nt') || params.blast_options?.contains('all') }
            ],
            'blastdb_nr': [
                'description': 'NCBI BLAST protein database',
                'type': 'blast_db',
                'extensions': ['.pal', '.phr', '.pin', '.psq'],
                'condition': { params.blast_options?.contains('nr') || params.blast_options?.contains('all') }
            ],
            'diamonddb': [
                'description': 'DIAMOND protein database',
                'type': 'file',
                'extensions': ['.dmnd'],
                'condition': { params.blastx_tool == 'diamond' }
            ]
        ]
        
        // Error message templates
        error_messages = [
            'missing_file': 'File not found: {file_path}. Please check the path and ensure the file exists.',
            'unreadable_file': 'File is not readable: {file_path}. Please check file permissions.',
            'empty_file': 'File is empty: {file_path}. Please provide a valid file with content.',
            'invalid_format': 'Unsupported file format: {format}. Supported formats: {supported_formats}',
            'missing_column': 'Required column missing: {column}. Required columns: {required_columns}',
            'duplicate_sample': 'Duplicate sample name found: {sample_name}. Sample names must be unique.',
            'invalid_fastq_extension': 'Invalid FASTQ file extension: {file_path}. Expected extensions: {valid_extensions}',
            'missing_database': 'Required database not found: {db_name} at {db_path}. Please install the database.',
            'invalid_database': 'Database validation failed for {db_name}: {reason}',
            'configuration_error': 'Configuration error: {parameter} = {value}. {suggestion}'
        ]
        
        // Suggestion templates
        suggestions = [
            'convert_excel': 'Convert your Excel file to CSV format using: Save As > CSV (Comma delimited)',
            'fix_permissions': 'Fix file permissions using: chmod 644 {file_path}',
            'download_database': 'Download {db_name} from: {download_url}',
            'check_path': 'Verify the file path is correct and the file exists',
            'example_samplesheet': '''
Example samplesheet format:
sample,fastq_1,fastq_2
sample1,/path/to/sample1_R1.fastq.gz,/path/to/sample1_R2.fastq.gz
sample2,/path/to/sample2_R1.fastq.gz,/path/to/sample2_R2.fastq.gz
            '''.stripIndent()
        ]
        
        // Validation report settings
        report = [
            'generate_report': true,
            'report_format': 'text',  // Options: 'text', 'json', 'html'
            'include_suggestions': true,
            'include_warnings': true,
            'save_to_file': true,
            'report_filename': 'validation_report.txt'
        ]
    }
}

// Validation process configuration
process {
    withName: 'VALIDATE_DATABASES' {
        label = 'process_low'
        cpus = 1
        memory = '2.GB'
        time = '10.min'
        
        publishDir = [
            path: "${params.outdir}/validation",
            mode: 'copy',
            pattern: "*.txt"
        ]
    }
    
    withName: 'VALIDATE_INPUT_FILES' {
        label = 'process_low'
        cpus = 1
        memory = '1.GB'
        time = '5.min'
        
        publishDir = [
            path: "${params.outdir}/validation",
            mode: 'copy',
            pattern: "*_validation.txt"
        ]
    }
}

// Custom validation functions
def validateParameter(paramName, paramValue, validOptions = null, required = true) {
    if (required && !paramValue) {
        error "Required parameter '${paramName}' is not set"
    }
    
    if (validOptions && paramValue && !validOptions.contains(paramValue)) {
        error "Invalid value for '${paramName}': ${paramValue}. Valid options: ${validOptions.join(', ')}"
    }
}

def validatePath(paramName, path, mustExist = true, mustBeReadable = true) {
    if (!path) return
    
    def file = new File(path.toString())
    
    if (mustExist && !file.exists()) {
        error "Path for '${paramName}' does not exist: ${path}"
    }
    
    if (mustBeReadable && file.exists() && !file.canRead()) {
        error "Path for '${paramName}' is not readable: ${path}"
    }
}

def validateDatabasePath(dbName, dbPath, dbType = 'directory') {
    if (!dbPath) {
        log.warn "Database '${dbName}' is not configured"
        return
    }
    
    def path = new File(dbPath.toString())
    
    if (!path.exists()) {
        error "Database '${dbName}' not found at: ${dbPath}"
    }
    
    if (dbType == 'directory' && !path.isDirectory()) {
        error "Database '${dbName}' path is not a directory: ${dbPath}"
    }
    
    if (dbType == 'file' && !path.isFile()) {
        error "Database '${dbName}' path is not a file: ${dbPath}"
    }
    
    if (!path.canRead()) {
        error "Database '${dbName}' is not readable: ${dbPath}"
    }
}

// Pre-run validation
def performPreRunValidation() {
    log.info "Performing pre-run validation..."
    
    // Validate tool selection parameters
    validateParameter('trimming_tool', params.trimming_tool, ['fastp', 'flexbar', 'trim_galore'])
    validateParameter('assembler', params.assembler, ['megahit', 'metaspades', 'hybrid'])
    validateParameter('blastx_tool', params.blastx_tool, ['diamond', 'blastx'])
    
    // Validate required databases
    validateDatabasePath('kraken2_db', params.kraken2_db, 'directory')
    validateDatabasePath('checkv_db', params.checkv_db, 'directory')
    
    // Validate optional databases based on configuration
    if (params.blast_options?.contains('viruses') || params.blast_options?.contains('all')) {
        validateDatabasePath('blastdb_viruses', params.blastdb_viruses, 'blast_db')
    }
    
    if (params.blast_options?.contains('nt') || params.blast_options?.contains('all')) {
        validateDatabasePath('blastdb_nt', params.blastdb_nt, 'blast_db')
    }
    
    if (params.blast_options?.contains('nr') || params.blast_options?.contains('all')) {
        validateDatabasePath('blastdb_nr', params.blastdb_nr, 'blast_db')
    }
    
    if (params.blastx_tool == 'diamond') {
        validateDatabasePath('diamonddb', params.diamonddb, 'file')
    }
    
    // Validate adapter file if specified
    if (params.adapters) {
        validatePath('adapters', params.adapters)
    }
    
    log.info "Pre-run validation completed successfully"
}